% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transforms.R
\docType{data}
\name{ssqrt_trans}
\alias{ssqrt_trans}
\alias{pseudolog10_trans}
\alias{interp_trans}
\alias{warp_trans}
\title{transforms .}
\format{An object of class \code{trans} of length 6.}
\usage{
ssqrt_trans

pseudolog10_trans

interp_trans(x = NULL, y = NULL, data = NULL, na.rm = TRUE)

warp_trans(x = NULL, w = NULL, data = NULL, na.rm = TRUE)
}
\arguments{
\item{x}{the \eqn{x} coordinates for linear interpolation.}

\item{y}{the \eqn{y} coordinates for linear interpolation.}

\item{data}{A \code{data.frame} with columns of \code{x} and \code{y}
for \code{interp_trans} or \code{x} and \code{w} for
\code{warp_trans}. If \code{data} is given, it takes precedence over
the given \code{x, y, w}.}

\item{w}{the \eqn{w} coordinates for the \sQuote{warp} interpolation.
The cumulative sum of \code{w} are computed then fed to the
interpolation transform.}
}
\value{
A scale transformation object.
}
\description{
Various scale transformations.
}
\details{
The available transforms:
\itemize{
\item \code{ssqrt_trans} a signed square root transform appropriate for
negative or positive numbers.
\item \code{pseudolog10_trans} an \code{asinh} transformation, which is like
a logarithm, but appropriate for negative or positive numbers.
\item \code{interp_trans} a function which generates a transform. The
user must supply \eqn{x} and \eqn{y}; the output transform performs the
linear interpolation from \eqn{x} to \eqn{y}. So, for example, to 
achieve something like a square root scale, let \eqn{x} span the domain
of interest and let \eqn{y = \sqrt{x}}.
\item \code{warp_trans} a function which generates a transform. This
is similar to \code{interp_trans}, but it accepts an \eqn{x} and 
non-negative \eqn{w} (\sQuote{weights}) which give the 
\emph{rate} of increase.  The data are resorted along \eqn{x}, 
then the cumulative sum of the \eqn{w} are computed and used as \eqn{y}
in linear interpolation via \code{interp_trans}.
}
}
\examples{
ggplot(data.frame(x=rnorm(100),y=runif(100)),aes(x=x,y=y)) + geom_point() + scale_x_continuous(trans=ssqrt_trans)

ggplot(data.frame(x=rnorm(100),y=runif(100)),aes(x=x,y=y)) + 
  geom_point() + 
  scale_x_continuous(trans=interp_trans(x=seq(-10,10,by=1),y=cumsum(runif(21))))

ggplot(data.frame(x=rnorm(100),y=runif(100)),aes(x=x,y=y)) + 
  geom_point() + 
  scale_x_continuous(trans=warp_trans(x=seq(-10,10,by=1),w=runif(21)))

# equivalently:
ggplot(data.frame(x=rnorm(100),y=runif(100)),aes(x=x,y=y)) + 
  geom_point() + 
  scale_x_continuous(trans=warp_trans(data=data.frame(x=seq(-10,10,by=1),w=runif(21))))

# this is like trans_sqrt:
myx <- seq(0,5,by=0.01)
ggplot(data.frame(x=rnorm(100),y=runif(100)),aes(x=x,y=y)) + 
  geom_point() + 
  scale_y_continuous(trans=interp_trans(x=myx,y=sqrt(myx)))

}
\seealso{
\code{\link{scales::trans_new}}.

\url{http://www.win-vector.com/blog/2012/03/modeling-trick-the-signed-pseudo-logarithm/}
}
\author{
Steven E. Pav \email{steven@gilgamath.com}
}
\keyword{datasets}
\keyword{plotting}
